<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced UFO Spaceship - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h3>Advanced UFO Spaceship</h3>
        <p>Three.js with Custom Shaders & Textures</p>
    </div>
    <div id="controls">
        <p><strong>Controls:</strong></p>
        <p>Mouse: Rotate camera</p>
        <p>Scroll: Zoom in/out</p>
        <p>WASD: Move camera</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Scene setup
        let scene, camera, renderer, controls;
        let ufoGroup, ufoBody, ufoDome, ufoRing, ufoLights;
        let starField, nebula;
        let animationId;
        
        // Shader materials
        let ufoBodyMaterial, ufoDomeMaterial, ufoRingMaterial;
        
        // Animation variables
        let time = 0;
        const clock = new THREE.Clock();
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 1, 15000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 5, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 5;
            
            // Create space background
            createSpaceBackground();
            
            // Create UFO
            createUFO();
            
            // Add lighting
            setupLighting();
            
            // Start animation
            animate();
        }
        
        // Create space background with stars and nebula
        function createSpaceBackground() {
            // Create star field
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 10000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 20000;
                starPositions[i + 1] = (Math.random() - 0.5) * 20000;
                starPositions[i + 2] = (Math.random() - 0.5) * 20000;
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.55);
                starColors[i] = color.r;
                starColors[i + 1] = color.g;
                starColors[i + 2] = color.b;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            
            // Create nebula background
            const nebulaGeometry = new THREE.SphereGeometry(15000, 32, 32);
            const nebulaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    void main() {
                        vec3 color1 = vec3(0.1, 0.0, 0.3);
                        vec3 color2 = vec3(0.0, 0.1, 0.4);
                        vec3 color3 = vec3(0.2, 0.0, 0.5);
                        
                        float n1 = noise(vPosition * 0.01 + time * 0.1);
                        float n2 = noise(vPosition * 0.02 + time * 0.05);
                        float n3 = noise(vPosition * 0.005 + time * 0.02);
                        
                        vec3 finalColor = mix(color1, color2, n1);
                        finalColor = mix(finalColor, color3, n2 * n3);
                        
                        gl_FragColor = vec4(finalColor, 0.3);
                    }
                `,
                side: THREE.BackSide,
                transparent: true
            });
            
            nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }
        
        // Create the UFO spaceship
        function createUFO() {
            ufoGroup = new THREE.Group();
            
            // UFO Body (main disc)
            const bodyGeometry = new THREE.CylinderGeometry(6, 8, 1.5, 32, 1);
            ufoBodyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    metalness: { value: 0.9 },
                    roughness: { value: 0.1 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        vec3 pos = position;
                        pos.y += sin(pos.x * 10.0 + time) * 0.02;
                        pos.y += cos(pos.z * 8.0 + time * 1.2) * 0.015;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float metalness;
                    uniform float roughness;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 baseColor = vec3(0.7, 0.8, 0.9);
                        
                        // Panel lines
                        float panels = sin(vUv.x * 20.0) * sin(vUv.y * 15.0);
                        panels = smoothstep(0.7, 0.9, panels);
                        
                        // Metallic reflection
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        
                        // Energy pulse
                        float pulse = sin(time * 3.0 + vUv.x * 10.0) * 0.5 + 0.5;
                        vec3 energyColor = vec3(0.0, 0.8, 1.0) * pulse * 0.3;
                        
                        vec3 finalColor = baseColor + panels * 0.2 + fresnel * 0.3 + energyColor;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });
            
            ufoBody = new THREE.Mesh(bodyGeometry, ufoBodyMaterial);
            ufoBody.castShadow = true;
            ufoBody.receiveShadow = true;
            ufoGroup.add(ufoBody);
            
            // UFO Dome (cockpit)
            const domeGeometry = new THREE.SphereGeometry(3, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.6);
            ufoDomeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 baseColor = vec3(0.1, 0.3, 0.8);
                        
                        // Glass effect
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        
                        // Interior glow
                        float glow = sin(time * 2.0) * 0.3 + 0.7;
                        vec3 glowColor = vec3(0.0, 1.0, 0.8) * glow * 0.5;
                        
                        // Reflection patterns
                        float pattern = sin(vUv.x * 30.0) * sin(vUv.y * 20.0) * 0.1;
                        
                        vec3 finalColor = baseColor + fresnel * 0.6 + glowColor + pattern;
                        float alpha = 0.7 + fresnel * 0.3;
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            ufoDome = new THREE.Mesh(domeGeometry, ufoDomeMaterial);
            ufoDome.position.y = 0.8;
            ufoDome.castShadow = true;
            ufoGroup.add(ufoDome);
            
            // UFO Ring (outer edge)
            const ringGeometry = new THREE.TorusGeometry(9, 0.5, 8, 32);
            ufoRingMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        
                        vec3 pos = position;
                        pos += normal * sin(time * 4.0 + position.x * 5.0) * 0.05;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        vec3 baseColor = vec3(0.9, 0.7, 0.3);
                        
                        // Energy flow
                        float flow = sin(vUv.x * 20.0 - time * 5.0) * 0.5 + 0.5;
                        vec3 energyColor = vec3(1.0, 0.5, 0.0) * flow;
                        
                        // Metallic shine
                        float shine = pow(max(dot(vNormal, vec3(0.0, 1.0, 0.0)), 0.0), 3.0);
                        
                        vec3 finalColor = baseColor + energyColor * 0.5 + shine * 0.3;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });
            
            ufoRing = new THREE.Mesh(ringGeometry, ufoRingMaterial);
            ufoRing.position.y = -0.3;
            ufoRing.castShadow = true;
            ufoGroup.add(ufoRing);
            
            // Add landing lights
            createUFOLights();
            
            // Add details
            addUFODetails();
            
            scene.add(ufoGroup);
        }
        
        // Create UFO lights
        function createUFOLights() {
            const lightGroup = new THREE.Group();
            
            // Bottom lights
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 7;
                
                const lightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i / 8, 1, 0.8),
                    transparent: true,
                    opacity: 0.9
                });
                
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.x = Math.cos(angle) * radius;
                light.position.z = Math.sin(angle) * radius;
                light.position.y = -1;
                
                // Add point light
                const pointLight = new THREE.PointLight(lightMaterial.color, 1, 10);
                pointLight.position.copy(light.position);
                lightGroup.add(pointLight);
                
                lightGroup.add(light);
            }
            
            ufoLights = lightGroup;
            ufoGroup.add(lightGroup);
        }
        
        // Add UFO details
        function addUFODetails() {
            // Add antenna
            const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.1, 2, 8);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.y = 2.5;
            ufoGroup.add(antenna);
            
            // Add antenna tip
            const tipGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const tipMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            tip.position.y = 3.5;
            ufoGroup.add(tip);
            
            // Add exhaust ports
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const radius = 5;
                
                const exhaustGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.5, 8);
                const exhaustMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
                
                exhaust.position.x = Math.cos(angle) * radius;
                exhaust.position.z = Math.sin(angle) * radius;
                exhaust.position.y = -1.2;
                
                ufoGroup.add(exhaust);
            }
        }
        
        // Setup lighting
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0x0088ff, 0.5);
            rimLight.position.set(-10, 5, -5);
            scene.add(rimLight);
        }
        
        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            time = clock.getElapsedTime();
            
            // Update shader uniforms
            if (ufoBodyMaterial) ufoBodyMaterial.uniforms.time.value = time;
            if (ufoDomeMaterial) ufoDomeMaterial.uniforms.time.value = time;
            if (ufoRingMaterial) ufoRingMaterial.uniforms.time.value = time;
            if (nebula) nebula.material.uniforms.time.value = time;
            
            // Rotate UFO
            if (ufoGroup) {
                ufoGroup.rotation.y += 0.005;
                ufoGroup.position.y = Math.sin(time * 0.5) * 0.5;
                
                // Animate lights
                if (ufoLights) {
                    ufoLights.rotation.y += 0.02;
                    ufoLights.children.forEach((child, index) => {
                        if (child.material && child.material.opacity !== undefined) {
                            child.material.opacity = 0.7 + Math.sin(time * 3 + index) * 0.3;
                        }
                    });
                }
            }
            
            // Rotate star field slowly
            if (starField) {
                starField.rotation.y += 0.0002;
            }
            
            // Update controls
            controls.update();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Keyboard controls
        function setupKeyboardControls() {
            const keys = {};
            
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
            
            function updateCameraPosition() {
                const speed = 0.5;
                
                if (keys['KeyW']) camera.position.z -= speed;
                if (keys['KeyS']) camera.position.z += speed;
                if (keys['KeyA']) camera.position.x -= speed;
                if (keys['KeyD']) camera.position.x += speed;
                
                requestAnimationFrame(updateCameraPosition);
            }
            
            updateCameraPosition();
        }
        
        // Event listeners
        window.addEventListener('resize', onWindowResize);
        
        // Initialize everything
        init();
        setupKeyboardControls();
        
        // Cleanup function
        function cleanup() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            if (renderer) {
                renderer.dispose();
            }
            
            // Dispose geometries and materials
            scene.traverse((object) => {
                if (object.geometry) {
                    object.geometry.dispose();
                }
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
